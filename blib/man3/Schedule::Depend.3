.\" Automatically generated by Pod::Man version 1.19
.\" Fri Mar  1 12:26:11 2002
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Depend 3"
.TH Depend 3 "perl v5.6.0" "2002-03-01" "User Contributed Perl Documentation"
.UC
.SH "Name"
.IX Header "Name"
Schedule::Depend
.SH "Synopsis"
.IX Header "Synopsis"
Single argument is assumed to be a schedule, either newline 
delimited text or array referent:
.PP
.Vb 1
\&        my $q = Scheduler->prepare( "newline delimited schedule" );
.Ve
.Vb 1
\&        my $q = Scheduler->prepare( [ qw(array ref of schedule lines) ] );
.Ve
Multiple items are assumed to be a hash, which much include the
\&\*(L"depend\*(R" argument.
.PP
.Vb 1
\&        my $q = Scheduler->prepare( depend => "foo:bar", verbose => 1 );
.Ve
Object can be saved and used to execute the schedule or the schedule
can be executed (or debugged) directly:
.PP
.Vb 2
\&        $q->debug;
\&        $q->execute;
.Ve
.Vb 2
\&        Scheduler->prepare( depend => $depend)->debug;
\&        Scheduler->prepare( depend => $depend, verbose => 1  )->execute;
.Ve
Since the deubgger exits nonzero on a bogus queue:
.PP
.Vb 1
\&        Scheduler->prepare( depend => $depend)->debug->execute;
.Ve
The \*(L"unalias\*(R" method can be safely overloaded for specialized
command construction at runtime; precheck can be overloaded in
cases where the status of a job can be determined easily (e.g.,
via /proc). A \*(L"cleanup\*(R" method may be provided, and will be
called after the job is complete.
.SH "Arguments"
.IX Header "Arguments"
.IP "depend" 4
.IX Item "depend"
The dependencies are described much like a Makefile, with targets
waiting for other jobs to complete on the left and the dependencies
on the right. Schedule lines can have single dependencies like:
.Sp
.Vb 1
\&        waits_for : depends_on
.Ve
or multiple dependencies:
.Sp
.Vb 1
\&        wait1 wait2 : dep1 dep2 dep3
.Ve
or no dependencies:
.Sp
.Vb 1
\&        runs_immediately :
.Ve
Dependencies without a wait_for argument are an error.
.Sp
The schedule can be passed as a single argument (string or
referent) or with the \*(L"depend\*(R" key as a hash value:
.Sp
.Vb 1
\&        depend => [ schedule as seprate lines in an array ]
.Ve
.Vb 1
\&        or
.Ve
.Vb 1
\&        depend => "newline delimited schedule, one item per line";
.Ve
.IP "verbose" 4
.IX Item "verbose"
Turns on verbose execution for preparation and execution.
.SH "Description"
.IX Header "Description"
Parallel scheduler with simplified make syntax for job 
dependencies and substitutions.  Like make, targets have
dependencies that must be completed before the can be run. 
Unlike make there are no statements for the targets, the targets
are themselves executables.
.Sp
The use of pidfiles with status information allows running
the queue in \*(L"restart\*(R" mode. This skips any jobs with zero
exit status in their pidfiles, stops and re-runs or waits for
any running jobs and launches anything that wasn't started.
This should allow a schedule to be re-run with a minimum of
overhead.
.Sp
Each job is executed via fork/exec. The parent writes out a 
pidfile with initially two lines: pid and command line. It
then closes the pidfile.  After the parent detectes the child
process exiting the exit status is written to the file and
the file closed.
.Sp
The pidfile serves three purposes:
.Sp
.Vb 2
\& -      On restart any leftover pidfiles with
\&        a zero exit status in them can be skipped.
.Ve
.Vb 5
\& -      Any process used to monitor the result of
\&        a job can simply perform a blocking I/O to
\&        for the exit status to know when the job
\&        has completed. This avoids the monitoring
\&        system having to poll the status.
.Ve
.Vb 4
\& -      Tracking the empty pidfiles gives a list of
\&        the pending jobs. This is mainly useful with
\&        large queues where running in verbose mode 
\&        would generate execesive output.
.Ve
The configuration syntax is make-like. The two sections
give aliases and the schedule itself. Aliases and targets
look like make rules:
.Sp
.Vb 1
\&        target = expands_to
.Ve
.Vb 1
\&        target : dependency
.Ve
example:
.Sp
.Vb 3
\&        a = /somedir/abjob.ksh
\&        b = /somedir/another.ksh
\&        c = /somedir/loader
.Ve
.Vb 2
\&        a : /somedir/startup.ksh 
\&        b : /somedir/startup.ksh
.Ve
.Vb 1
\&        c : a b
.Ve
.Vb 1
\&        /somedir/validate : a b c
.Ve
Will use the various path expansions for \*(L"a\*(R", \*(L"b\*(R" and \*(L"c\*(R"
in the targets and rules, running /somedir/abjob.ksh only
after /somedir/startup.ksh has exited zero, the same for
/somedir/another.ksh. The file /somedir/loader
gets run only after both abjob.ksh and another.ksh are 
done with and the validate program gets run only after all
of the other three are done with.
.Sp
The main uses of aliases would be to simplify re-use of 
scripts. One example is the case where the same code gets
run multiple times with different arguments:
.Sp
.Vb 2
\&        # comments are introduced by '#', as usual.
\&        # blank lines are also ignored.
.Ve
.Vb 6
\&        a = /somedir/process 1 
\&        b = /somedir/process 2 
\&        c = /somedir/process 3 
\&        d = /somedir/process 4 
\&        e = /somedir/process 5 
\&        f = /somedir/process 6
.Ve
.Vb 3
\&        a : /otherdir/startup   # startup.ksh isn't aliased
\&        b : /otherdir/startup
\&        c : /otherdir/startup
.Ve
.Vb 3
\&        d : a b
\&        e : b c 
\&        f : d e
.Ve
.Vb 1
\&        cleanup : a b c d e f
.Ve
Would allow any variety of arguments to be run for the 
a-f code simply by changing the aliases, the dependencies
remain the same.
.Sp
Another example is a case of loading fact tables after the
dimensions complete:
.Sp
.Vb 1
\&        fact1 fact2 fact3 : dim1 dim2 dim3
.Ve
Would load all of the dimensions at once and the facts
afterward. Note that stub entries are not required
for the dimensions, they are added as runnable jobs 
when the rule is read.
.Sp
Overloading the \*(L"unalias\*(R" method to properly select the
shell comand for loading the files would leave this as
the entire schedule. An example overloaded method would
look like:
.Sp
.Vb 4
\&        sub unalias
\&        {
\&                my $que = shift;
\&                my $diskfile = shift;
.Ve
.Vb 1
\&                my $tmufile = "$tmudir/$diskfile.tmu";
.Ve
.Vb 1
\&                -e $tmufile or croak "$$: Missing: $tmufile";
.Ve
.Vb 1
\&                my $logfile = "$logdir/$diskfile.log";
.Ve
.Vb 1
\&                # hand back the completed tmu command.
.Ve
.Vb 2
\&                "rb_tmu $tmufile \e$RB_USER < $diskfile > $logfile 2>&1"
\&        }
.Ve
A more flexable unalias might decide if the file should
be unzipped and piped or simply redirected and whether
to zip the logfile as it is processed.
.Sp
Since the executed code is fork-execed it can contain any
useful environment variables also:
.Sp
.Vb 1
\&        a = process --seq 1 --foo=$BAR
.Ve
will interpolate \f(CW$BAR\fR at fork-time in the child process (i.e..
by the shell handling the exec portion).
.Sp
The scheduling module exports modules for managing the 
preparation, validation and execution of schedule objects.
Since these are separated they can be manipulated by the
caller as necessary.
.Sp
One example would be to read in a set of schedules, run
the first one to completion, modify the second one based
on the output of the first. This might happen when jobs are
used to load data that is not always present.  The first
schedule would run the data extract/import/tally graphs.
Code could then check if the tally shows any work for the
intermittant data and stub out the processing of it by
aliasing the job to \*(L"/bin/true\*(R":
.Sp
.Vb 1
\&        /somedir/somejob.ksh = /bin/true
.Ve
.Vb 1
\&        prepare = /somedir/extract.ksh
.Ve
.Vb 1
\&        load = /somedir/batchload.ksh
.Ve
.Vb 3
\&        /somedir/somejob.ksh : prepare 
\&        /somedir/ajob.ksh : prepare 
\&        /somedir/bjob.ksh : prepare
.Ve
.Vb 1
\&        load : /somedir/somejob.ksh /somedir/ajob.ksh /somedir/bjob.ksh
.Ve
In this case /somedir/somejob.ksh will be stubbed to exit
zero immediately. This will not interfere with any of the
scheduling patterns, just reduce any dealays in the schedule.
.SH "Known Bugs"
.IX Header "Known Bugs"
Running \f(CW$q\fR->debug then \f(CW$q\fR->execute( ... restart => 1 ) will 
result in nothing being executed. The restart option will
check, find that all of the 
.SH "Author"
.IX Header "Author"
Steven Lembark, Knightsbridge Solutions
slembark@knightsbridge.com
.SH "Copyright"
.IX Header "Copyright"
(C) 2001\-2002 Steven Lembark, Knightsbridge Solutions
.Sp
This code is released under the same terms as Perl istelf. Please
see the Perl-5.6.1 distribution (or later) for a full description.
.Sp
In any case, this code is release as-is, with no implied warranty
of fitness for a particular purpose or warranty of merchantability.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1).
